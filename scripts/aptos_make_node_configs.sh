#!/usr/bin/env bash
set -euo pipefail

# Usage:
#   ./make_node_configs.sh /path/to/aptos-core /tmp/aptos-dstest 4 7000
#
# Creates:
#   /tmp/aptos-dstest/nodes/v0/node.yaml, data/, genesis/
#   ...
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
APTOS_ROOT="${SCRIPT_DIR}/../../aptos-core"
BASE_DIR="${1:-/tmp/aptos-dstest}"
NUM_NODES="${2:-4}"
BASE_PORT="${3:-8000}"

GENESIS_DIR="${BASE_DIR}/genesis"
NODES_DIR="${BASE_DIR}/nodes"

TEMPLATE="${APTOS_ROOT}/docker/compose/aptos-node/validator.yaml"
if [[ ! -f "${TEMPLATE}" ]]; then
  echo "ERROR: Could not find validator template at: ${TEMPLATE}"
  echo "Search for it with: find \"${APTOS_ROOT}\" -path '*aptos-node*' -name 'validator.yaml' | head"
  exit 1
fi

test -f "${GENESIS_DIR}/genesis.blob" || { echo "Missing ${GENESIS_DIR}/genesis.blob"; exit 1; }
test -f "${GENESIS_DIR}/waypoint.txt"  || { echo "Missing ${GENESIS_DIR}/waypoint.txt"; exit 1; }

mkdir -p "${NODES_DIR}"

# Port plan per node i:
# - REST API:          BASE_PORT + i*10 + 0
# - Metrics (optional) BASE_PORT + i*10 + 1
# - VFN listen:        BASE_PORT + i*10 + 2
# - Validator net:     BASE_PORT + i*10 + 3
# - Validator net pub: BASE_PORT + i*10 + 4 (if used)
for i in $(seq 0 $((NUM_NODES - 1))); do
  NODE_DIR="${NODES_DIR}/v${i}"
  mkdir -p "${NODE_DIR}/data" "${NODE_DIR}/genesis"

  cp -f "${GENESIS_DIR}/genesis.blob" "${NODE_DIR}/genesis/genesis.blob"
  cp -f "${GENESIS_DIR}/waypoint.txt"  "${NODE_DIR}/genesis/waypoint.txt"

  # Identity blobs: generated by `aptos genesis generate-keys`
  KEY_DIR="${GENESIS_DIR}/n${i}_keys"
  test -f "${KEY_DIR}/validator-identity.yaml" || {
    echo "ERROR: Missing ${KEY_DIR}/validator-identity.yaml"
    echo "Check: ls -la ${KEY_DIR}"
    exit 1
  }
  cp -f "${KEY_DIR}/validator-identity.yaml" "${NODE_DIR}/genesis/validator-identity.yaml"

  # Some templates reference validator-full-node-identity.yaml; copy if present
  if [[ -f "${KEY_DIR}/validator-full-node-identity.yaml" ]]; then
    cp -f "${KEY_DIR}/validator-full-node-identity.yaml" "${NODE_DIR}/genesis/validator-full-node-identity.yaml"
  fi

  API_PORT=$((BASE_PORT + i*10 + 0))
  VFN_PORT=$((BASE_PORT + i*10 + 2))
  VAL_PORT=$((BASE_PORT + i*10 + 3))
  WARP_PORT=$((BASE_PORT + i*10 + 6))      # inspection_service (warp) replaces default 6186
  ADMIN_PORT=$((BASE_PORT + i*10 + 7))     # admin_service replaces default port(s)
  BACKUP_PORT=$((BASE_PORT + i*10 + 8))

  # Start from template and patch paths/ports.
  # We use python to safely edit YAML rather than sed.
  python3 - <<PY
import yaml, pathlib, re

tmpl = pathlib.Path("${TEMPLATE}")
outp = pathlib.Path("${NODE_DIR}/node.yaml")

cfg = yaml.safe_load(tmpl.read_text())

# --- Paths
node_dir = pathlib.Path("${NODE_DIR}")
cfg.setdefault("base", {})
cfg["base"]["data_dir"] = str(node_dir / "data")

# Waypoint / genesis locations (common locations in validator template)
cfg.setdefault("execution", {})
cfg["execution"]["genesis_file_location"] = str(node_dir / "genesis" / "genesis.blob")

cfg["base"].setdefault("waypoint", {})
cfg["base"]["waypoint"]["from_file"] = str(node_dir / "genesis" / "waypoint.txt")

# Identity blob path: usually used by validator network mutual auth and/or safety rules
identity_path = str(node_dir / "genesis" / "validator-identity.yaml")

# Try to patch common identity locations if present
# validator_network.identity.path
vn = cfg.get("validator_network")
if isinstance(vn, dict):
  ident = vn.get("identity")
  if isinstance(ident, dict):
    ident["path"] = identity_path

# consensus.safety_rules...identity_blob_path (some templates)
cons = cfg.get("consensus")
if isinstance(cons, dict):
  sr = cons.get("safety_rules")
  if isinstance(sr, dict):
    init = sr.get("initial_safety_rules_config")
    if isinstance(init, dict):
      ff = init.get("from_file")
      if isinstance(ff, dict):
        ff["identity_blob_path"] = identity_path
        wp = ff.get("waypoint")
        if isinstance(wp, dict):
          wp["from_file"] = str(node_dir / "genesis" / "waypoint.txt")

# --- Ports
# REST API
api = cfg.get("api")
if isinstance(api, dict):
  api["address"] = f"0.0.0.0:{${API_PORT}}"

# --- Force internal service ports that otherwise default & collide
warp_port = ${WARP_PORT}         # replaces default 6186
admin_port = ${ADMIN_PORT}    # replaces default 9101/6180-ish
backup_port = ${BACKUP_PORT}

# inspection_service
cfg["inspection_service"] = cfg.get("inspection_service") or {}
if isinstance(cfg["inspection_service"], dict):
    cfg["inspection_service"].pop("address", None)
    cfg["inspection_service"]["port"] = int(warp_port)

# admin_service
cfg["admin_service"] = cfg.get("admin_service") or {}
if isinstance(cfg["admin_service"], dict):
    cfg["admin_service"].pop("address", None)
    cfg["admin_service"]["port"] = int(admin_port)

# backup service address lives under storage
cfg.setdefault("storage", {})
cfg["storage"]["backup_service_address"] = f"127.0.0.1:{backup_port}"

# Fullnode / VFN listen address (if present)
fns = cfg.get("full_node_networks")
if isinstance(fns, list) and len(fns) > 0:
  for net in fns:
    if isinstance(net, dict) and "listen_address" in net:
      # keep format, just replace tcp port at end
      la = net["listen_address"]
      # naive but effective: replace trailing /tcp/<port>
      if isinstance(la, str) and "/tcp/" in la:
        base = la.rsplit("/tcp/", 1)[0]
        net["listen_address"] = f"{base}/tcp/{${VFN_PORT}}"

# Validator network listen (if present)
vn = cfg.get("validator_network") or {}
cfg["validator_network"] = vn

# Force validator network listen address (otherwise it defaults to :6180)
vn["listen_address"] = f"/ip4/0.0.0.0/tcp/{${VAL_PORT}}"

# Write
outp.write_text(yaml.safe_dump(cfg, sort_keys=False))
print("Wrote", outp)
PY

done

echo "Generated node configs under: ${NODES_DIR}"
echo "Try: ls -ლა ${NODES_DIR}/v0 && head -n 40 ${NODES_DIR}/v0/node.yaml"